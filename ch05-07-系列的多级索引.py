# -*- coding: utf-8 -*-

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                        系列的多级索引
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

#%%
from pandas import Series
from string import letters
i = ['a','a','a','a','a','b','b','b','b','b','c']
j = [0,1,2,3,4,0,1,2,3,4,0]
k = [0,1,2,0,1,2,0,1,2,0,1]
s1 = Series(range(11),index=[i,j])
s2 = Series(range(11),index=[i,k])
#%%
s1
#%%
s2
#%%
s1['a']        # 返回一个系列，并且已经去掉了第1级的索引
#%%
s1['c']        # 即使返回只有一个元素，也是以系列的方式返回
#%%
s1['a',0]      # 可以使用[m,n]直接定位到一个元素，前提是索引唯一
               # 索引不唯一返回的是系列
#%%
s1['a':'b']    # 可以使用切片访问数据
#%%
s1['a':'b',1]  # 不能在[m,n]中同时使用切片
#%%
s1[:,1]        # 唯一能使用的切片运算符就是":"，用于直接访问第二层的下标
               # 这时会过滤掉第2级的索引，保留第1级的索引

#%% 
s1.unstack()   # 通过unstack()将Series转化为DataFrame(即将低维度数据转化为高维度数据)
               # 转化后，最低级的索引，变为列数据了
               # unstack()前提也是两级索引是合并起来是唯一的

#%%  检查复合索引是否重复
s1.index.is_unique
#%%
s2.index.is_unique

#%% 按某一级索引进行排序
s1.sortlevel(1)
#%% 交换索引的顺序
s1.swaplevel(0,1).sortlevel(0)

#%% 对每一级索引进行命名
s1.index.names=['char','num']
s1

#%% 命名后可以在函数中引用到
s1.swaplevel('char','num')
#%% 按多级索引做分类汇总
s1.sum(level='char')
#%%
s1.sum(level='num')

